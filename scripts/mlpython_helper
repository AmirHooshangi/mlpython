#! /usr/bin/env python

# Copyright 2011 David Brouillard & Guillaume Roy-Fontaine. All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without modification, are
# permitted provided that the following conditions are met:
# 
#    1. Redistributions of source code must retain the above copyright notice, this list of
#       conditions and the following disclaimer.
# 
#    2. Redistributions in binary form must reproduce the above copyright notice, this list
#       of conditions and the following disclaimer in the documentation and/or other materials
#       provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY David Brouillard & Guillaume Roy-Fontaine ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL David Brouillard & Guillaume Roy-Fontaine OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
# The views and conclusions contained in the software and documentation are those of the
# authors and should not be interpreted as representing official policies, either expressed
# or implied, of David Brouillard & Guillaume Roy-Fontaine.


import os
import imp
import inspect
import sys
import re
import warnings
import mlpython

modes = ["-datasets", "-learners"] # parameters of the scripts
storeFilePath = mlpython.__path__[0] + "/datasets/store.py" # store.py location

def VerifyMode():    
    arguments = sys.argv
    arguments.pop(0);	# Remove first argument
    
    if len(arguments) >= 1:
        if arguments[0] == modes[0]:
            VerifyDatasetsMode(arguments)
        elif arguments[0] == modes[1]:
            VerifyLearnersMode(arguments)
        else:
            print 'Usage:\n     mlpython_helper -datasets [dataset] or\n     mlpython_helper -learners [object]'
    else:
        print 'Usage:\n     mlpython_helper -datasets [dataset] or\n     mlpython_helper -learners [object]'
		
    
def VerifyDatasetsMode(args):    
    if len(args) == 1:
        ShowDatasets()
    elif len(args) == 2:
        ShowDatasetDocstring(args[1])
    elif len(args) >= 3:
        print 'Usage:\n     mlpython_helper -datasets [dataset] or\n     mlpython_helper -learners [object]'

 
def VerifyLearnersMode(args):
    if len(args) == 1:
        ShowLearners()
        #test()
    elif len(args) == 2:
        ShowClassDocstring(args[1])
    elif len(args) >= 3:
        print 'Usage:\n     mlpython_helper -datasets [dataset] or\n     mlpython_helper -learners [object]'
        
    
def ShowDatasets():
    # Get file contents
    fd = open(storeFilePath)
    contents = fd.readlines()
    fd.close()
    new_contents = GetRidEmptyLine(contents)

    densityNames = GetDatasetVariableFromContent('density_names =', new_contents)
    classificationNames = GetDatasetVariableFromContent('classification_names =', new_contents)
    multilabelNames = GetDatasetVariableFromContent('multilabel_names =', new_contents)
    multiregressionsNames = GetDatasetVariableFromContent('multiregression_names =', new_contents)
    
    print 'TASK = density'
    for item in densityNames:
        print '        -' + item

    print '\nTASK = classification'
    for item in classificationNames:
        print '        -' + item
        
    print '\nTASK = multilabel'
    for item in multilabelNames:
        print '        -' + item
        
    print '\nTASK = multiregression'
    for item in multiregressionsNames:
        print '        -' + item


def ShowLearners():
    filePath = mlpython.__path__[0] + "/learners"

    from mlpython.learners.generic import Learner
    for (path, dirs, files) in os.walk(filePath):
        for item in files:
            if item.find("__init__") == -1:
                match = re.search(r'py$', item)
                if match: # If-statement after search() tests if it succeeded                   
                    moduleLocalPath = path[path.rfind("/learners") + 1:len(path)] + '/' + item
                    modulePath = path + "/" + item

                    # Figuring out module from file name
                    module_import_str = moduleLocalPath.replace('/','.')
                    module_import_str = module_import_str[:module_import_str.rfind('.py')]

                    try:
                        exec 'import mlpython.' + module_import_str + ' as m'

                        found_one_learner = False
                        d = vars(m)
                        for x,y in d.items():
                            if inspect.isclass(y):
                                if issubclass(y,Learner) and y.__module__ == 'mlpython.'+module_import_str:
                                    if not found_one_learner:
                                        print 'MODULE: mlpython.' + module_import_str
                                        found_one_learner = True
                                    print '            -' + x
                    except Exception as inst:
                        pass
                        #print "*Unexpected import error: " + str(type(inst))
                        #print inst

            
def ShowDatasetDocstring(dataset):
    datasetFilePath = mlpython.__path__[0] + "/datasets/" + dataset + ".py"
    
    if os.path.isfile(datasetFilePath):
        print GetModuleDocstring(datasetFilePath)
    else:
        print 'Dataset \'' + dataset + '\' do not exist.'
        
        
def ShowClassDocstring(varClass):    
    filePath = mlpython.__path__[0] + "/learners"
    isFound = 0
    for (path, dirs, files) in os.walk(filePath):
        for item in files: # We do not want .pyc, __init__ and README files
            match = re.search(r'py$', item)
            if match:
                fd = open(path + "/" + item)
                contents = fd.readlines()
                fd.close()
                new_contents = GetRidEmptyLine(contents)
                classes = GetClassFromContent("class ", new_contents)
                if len(classes) > 0:
                    for item2 in classes:
                        if item2.find(varClass) >= 0:
                            isFound = 1

                            # Figuring out module from file name
                            module_import_str = path[path.find("/learners") + 1:len(path)] + '/' + item
                            module_import_str = module_import_str.replace('/','.')
                            module_import_str = module_import_str[:module_import_str.rfind('.py')]

                            print '\nMODULE: mlpython.' + module_import_str
                            classDocstring = GetClassDocstring(module_import_str, varClass)
                            print 'Docstring: ' + varClass
                            print classDocstring

    if isFound == 0:
        print 'Learner \'' + varClass + '\' do not exist'


def GetRidEmptyLine(contents):
    new_contents = []
    # Get rid of empty lines
    for line in contents:
        if not line.strip(): # Strip whitespace, should leave nothing if empty line was just "\n"
            continue
        else: # We got something, save it
            new_contents.append(line)
            
    return new_contents


def GetClassFromContent(varToSearch, contents):
    #Get class from content file
    l = []
    for index, item in enumerate(contents):
        if item.find(varToSearch) > -1:
            if item.find(":") > -1:
                if item.find("(") > -1:
                    if item.find(".") == -1:
                        l.append(item[item.find(" ") + 1:item.rfind("(")])

    return l  


def GetDatasetVariableFromContent(varToSearch, contents):
    #Get all density datasets from a content file
    l = []
    for index, item in enumerate(contents):
        if item.find(varToSearch) > -1:
            l.append(item[item.find("'") + 1:item.rfind("'")])
            end = 0
            i = 0
            while end == 0:
                i = i + 1
                right = contents[i + index].rfind("'")
                l.append(contents[i + index][contents[i + index].find("'") + 1:contents[i + index].rfind("'")])
                if contents[i + index].find(")") > -1:
                    end = 1

    return l

    
def GetClassDocstring(module_import_str, classs):

    exec 'import mlpython.' + module_import_str
    exec 'docstring = mlpython.' + module_import_str + '.' + classs + '.__doc__'

    return docstring
    
    
def GetModuleDocstring(filepath):
    "Get module-level docstring of Python module at filepath, e.g. 'path/to/file.py'."
    co = compile(open(filepath).read(), filepath, 'exec')
    if co.co_consts and isinstance(co.co_consts[0], basestring):
        docstring = co.co_consts[0]
    else:
        docstring = None
    return docstring
    

# MAIN CODE
with warnings.catch_warnings(record=True) as w:
    # Cause all warnings to always be triggered.
    #warnings.simplefilter("always")  # always print matching warnings
    warnings.simplefilter("ignore") # never print matching warnings
    #warnings.simplefilter("error")  # turn matching warnings into exceptions
    
    VerifyMode()

